# RabbitMQ

В проекте реализован асинхронный клиент для RabbitMQ.
Конфиг Kafka находится в **config/rabbit_config.py**.


## Конфиг

В конфиге задаются поля для установки соединения с RabbitMQ, а также поля, отвечающие за используемые обменники сообщений, очереди и ключи маршрутизации для сообщений.

## Прокси-соединение

Для экономии ресурсов клиент реализует отложенное подключение к RabbitMQ, которое осуществляется с помощью прокси-объекта (**brokers/rabbitmq/connection_proxy.py**). Прокси-соединение является разным для отдельных сущностей. Например, для отдельного консюмера используется один объект прокси, а для продюсера - другой объект.
После установки соединения оно сохраняется в переменную класса и далее переиспользуется.
Разрыв соединения с RabbitMQ осуществляется пользователем с помощью метода `disconnect()` конкретного прокси. В прокси-объекте используется подсчет количества пользователей одного соединения. При достижении количество пользователей нуля, соединение будет разорвано, иначе объект соединения останется подключенным к RabbitMQ. Это позволяет экономно использовать соединение и переиспользовать его разными сущностями.

## Консюмер

Код консюмера находится в **brokers/rabbitmq/consumer.py**. Консюмер получает одно сообщение за раз, причем при первом получении сообщения устанавливается соединение с RabbitMQ с помощью прокси-соединения и инициализируется объект канала.
Для остановки консюмера используется метод `disconnect()`, который остановит консюмер и, соответственно, разорвет соединение с RabbitMQ и закроет канал.
В консюмере реализована дополнительная очередь `self._queue: asyncio.Queue[aio_pika.abc.AbstractIncomingMessage] = asyncio.Queue()` с помощью библиотеки aiohhtp. Это было сделано для того, чтобы метод `retrieve()` возвращал сообщение и не требовал коллбэк в соответствии со спецификацией библиотеки aio-pika, которая использовалась для настоящей реализации.

## Продюсер

Код продюсера находится в **brokers/rabbitmq/producer.py**. Продюсер отправляет одно сообщение за раз, причем при первой отправке сообщения устанавливается соединение с RabbitMQ с помощью прокси-соединения. При отправке каждого сообщения оно проверяется на соответствии pydantic-модели, которая передается в инициализатор продюсера.
Для остановки продюсера используется метод `disconnect()`, который остановит продюсер и, соответственно, разорвет соединение с RabbitMQ и закроет канал.

## Конфигурация обменников сообщениями, очередей и ключей маршрутизации

Для конфигурации обменников сообщениями, очередей и ключей маршрутизации для работы с сообщениями предусмотрен UI для RabbitMQ, который работает в том же контейнере, что и RabbitMQ.
Дополнительно был реализован конфигуратор с помощью шаблона проектирования **Builder**. Абстрактный класс конфигуратора находится в **interfaces/base_rabbitmq_routing_configurator.py**. Класс **BaseRoutingBuilder** отвечает за объявление объектов обменников и очередей, а также связывания их между собой. Класс **BaseRoutingConfigurator** отвечает за конфигурацию самого маршрута сообщений, который под собой тянет методы класса **BaseRoutingBuilder**.
Конкретная реализация представлена в **brokers/rabbitmq/routing_configurator.py**. В ней создается один обменник сообщений и очередь, которые затем связываются между собой с помощью ключа маршрутизации. Названия обменника, очереди и ключа маршрутизации могут быть получены из конфига.

## DI-контейнер

Для инициализации объектов консюмера или продюсера соблюдается следующая цепочка создания объектов в di-контейнере:

```python
connection = providers.Factory(connection_proxy.AsyncRMQProducerConnectionProxy)
producer = providers.Factory(producer.RabbitMQProducer, connection)
```

Изначально создается объект прокси-соединения, который затем передается в объект продюсера/консюмера.
Далее продюсер/консюмер может быть использован для отправки/получения сообщений.

## Пример использования

Продюсер:

```python
connection = connection_proxy.AsyncRMQProducerConnectionProxy()
prod = producer.RabbitMQProducer(connection)

for i in range(10):
    body = {
        "id": i,
        "text": f"Hello {i}"
    }
    message = broker_message_dto.BrokerMessageDTO(
        body=body
    )

    await prod.produce(
        "testik",
        "key",
        message
    )
```

Консюмер:

```python
connection = connection_proxy.AsyncRMQConsumerConnectionProxy()
cons = consumer.RabbitMQConsumer(connection)

messages = []

while True:
    message = await cons.retrieve("testik")
    messages.append(message)
```
