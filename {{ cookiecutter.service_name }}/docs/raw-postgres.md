# Raw Postgres
Использование raw sql-запросов к БД Postgres реализовано через psycopg в синхронном режиме и через asyncpg - в асинхронном.
Конфиг postgres находится в **config/pg_config.py**.


## Прокси-соединение

Синхронное и асинхронное подключение к БД Postgres реализует интерфейс **ConnectionProxy** из **interfaces/base_proxy.py**.
В качестве необходимых аргументов, прокси-соединение принимает прокси для получения курсора и фабрику пулов соединений. 
Для соединения с базой используется метод `connect()`. Он возвращает объект прокси-курсора, который был проинициализирован
соединением, полученным из пула.
Разрыв соединения с Postgres осуществляется пользователем с помощью метода `disconnect()` конкретного прокси. 

## Курсор

Курсор бд представлен в двух вариантах - клиентском и серверном. Оба реализуют интерфейс **BasePostgresCursorProxy** из 
**interfaces/base_postgres_cursor_proxy.py**. Инициализация курсора осуществляется методом `init_cursor()`.
За получения записей из базы отвечает метод  `retrieve_many()`.

## Пул соединений

Для получения соединения с бд, используется пул соединений. Получение пула осуществляется через фабрику. Фабрика пулов представлена
в синхронном и асинхронном вариантах. 


## Репозиторий
Для работы с базой данных используется репозиторий в синхронном и асинхронном исполнении, который реализует интерфейс
**BaseRepository** из **interfaces/base_repository.py**.
В качестве обязательного параметра репозиторий принимает объект прокси-соединения.
Методы репозитория, для совершения операций с базой данных, используют приватный метод `_execute_query()`. 
В нем осуществляется получение сохраненного в прокси-соединении объекта курсора. 
Для выполнения запроса к базе, курсор принимает sql-строку и необходимые параметры.

## Unit of work

Для обеспечения транзакционности при работе с БД Postgres через psycopg было реализовано 2 UOW - для синхронной и асинхронной реализаций.
UOW реализован в виде контекстного менеджера, который в методе `__exit__()` вызывает `commit()` у объекта соединения 
или `rollback()` при появлении исключения.

## DI-контейнер

Для инициализации объекта UOW и дальнейшей работы с БД Postgres через psycopg соблюдается следующая цепочка создания объектов в di-контейнере:

```python
connection_pool_factory = providers.Singleton(
    psycopg_connection_pool_factory.PsycopgPoolFactory,
    config.postgres_dsn,
    config.connection_pool_size,
)
cursor_type = providers.AbstractFactory(cursor_proxy.BasePsycopgCursorProxy)
connection_proxy = providers.Factory(
    connection_proxy.PsycopgConnectionProxy, connection_pool_factory, cursor_type
)
psycopg_repository = providers.Factory(
    psycopg_repository.PsycopgSyncRepository, connection_proxy
)
psycopg_uow = providers.Factory(psycopg_uow.PsycopgSyncUOW, psycopg_repository)
```

Сначала инициализируется фабрика пулов соединений которая принимает объект настроек.
Выбор типа курсора оставлен на пользователя. При настройке приложения требуется переопределить тип курсора на тот, 
что необходим пользователю. Пример:

```python
app = FastAPI()
container = raw_postgres_container.PsycopgSyncContainer()
container.cursor_type.override(providers.Factory(psycopg_cursor_proxies.ClientPsycopgCursorProxy))
app.container = container
```
Далее происходит получение прокси-соединения, которое принимает аргументами объекты фабрики пулов и прокси-курсора.
Как только был получен объект прокси-соединения, инициализируется объект репозитория, 
который является аргументов для инициализатора объекта UOW.

В асинхронном варианте с библиотекой asyncpg используется аналогичная цепочка создания объектов.

## Пример использования psycopg UOW через DI-контейнер


```python
# some code

@inject
def psycopg_example(
    uow: PsycopgSyncUOW = Provide[PsycopgSyncContainer.psycopg_uow]
):
    with uow as u:
        u.repository.create(...)
        
# some code
```

## Механизм взаимодействия классов
В этой части более подробно рассматривается взаимодействие классов, которые нужны для работы с raw sql-запросами к БД Postgres.

### UOW
Для синхронного подключения в проекте предусмотрен класс **PsycopgSyncUOW**, для асинхронного - **AsyncpgUOW**. Они реализуют интерфейсы **BaseSyncUOW** и **BaseAsyncUOW**, соответственно.
Оба UOW содержат общие поля **repository** и **_cursor_proxy**, который инициализируется как **None**.
При вызове контекстного менеджера, поле **_cursor_proxy** будет ссылаться на объект курсора, который можно получить вызвав прокси-объект соединения, принадлежащий объекту репозитория. Такое разделение позволяет использовать объект репозитория в отрыве от UOW, который не знает ничего о подключении, в отличие от репозитория. Также присвоение полю **_cursor_proxy** объекта курсора только при заходе в контекстный менеджер позволяет экономить сетевые ресурсы для подключения к БД Postgres.
**AsyncpgUOW** в отличие от **PsycopgSyncUOW** также имеет поля для работы с транзакциями - **_transaction** и **_is_transaction_commited**. Использование отдельного объекта транзакции обусловлено особенностями библиотеки **asyncpg**, которая использует объект транзакции в контекстном менеджере объекта подключения. Для обхода этого ограничения можно использовать объект транзакции отдельно, однако следует помнить о ее своевременном закрытии.

### Репозиторий

В проект добавлено 2 базовых класса репозитория: **PsycopgSyncRepository** для синхронной работы с БД Postgres, **AsyncpgRepository** для асинхронной. Обра репозитория реализуют интерфейс **BaseRepository**.
Для начала работы с репозиторием нужно инициализировать поле **connection_proxy**, которое является объектом, содержащим объект соединения и контролирующим работу с ним.
Особенностью данных репозиториев является факт, что они не хранят в себе объект курсора или соединения. Для этого нужно вызвать protected-метод **_get_connection**. Это было сделано намеренно в целях безопасности, уменьшения количества проверок и инкапсуляции логики подключения, ведь соединение может оборваться как по причинам, не зависящим от пользователя, так и по его инициативе. Для предупреждения таких ситуаций проще воспользоваться посредником, предоставляющим интерфейс подключения. На практике это означает, что перед тем как выполнить запрос в БД, нужно вызвать метод **_get_connection** для получения объекта курсора или соединения.
В базовых классах репозиториев показаны примеры методов для взаимодействия с БД. Практически все они используют один protected-метод **_execute_query**, который инкапсулирует типичную логику выполнения запроса с помощью курсора. Однако, метод **_execute_query** не использует метод **list**, т.к. он взаимодействует только с прокси-курсором, забирая данные из БД либо целиком (client-side cursor), либо батчами (server-side cursor). О работе прокси-курсора будет рассказано ниже.

### Прокси-соединение
Прокси-соединение представляет собой объект, реализующий интерфейс **ConnectionProxy**. Для синхронного подключения используется **PsycopgConnectionProxy**, а для асинхронного - **AsyncpgConnectionProxy**.
Оба прокси-соединения инициализируют пул соединений и прокси-курсор. При вызове метода **connect** достается соединение из пула и инициализируется курсор в прокси-объекте курсора. Далее метод возвращает прокси-объект курсора, с помощью которого пользователь может выполнять запрос к БД. Метод **disconnect** закрывает курсор и вовзращает соединение в пул.
Объекты прокси-соединения способны работать как с client-side курсорами, так и с server-side - выбор курсора регулируется при инициализации прокси-соединения.


### Прокси-курсор
Прокси-курсоры наследуются от **BasePsycopgCursorProxy** в случае синхронного подключения, и от **BaseAsyncpgCursorProxy** в случае асинхронного. Базовые классы реализуют интерфейс **BasePostgresCursorProxy**.
Интерфейс имеет метод для инициализации курсора и для получения данных из БД выбранным курсором. Если понадобится добавить еще одну операцию, которая зависит от курсора, можно расширить интерфейс **BasePostgresCursorProxy** необходимым методом.
В реализации psycopg server-side курсор может выполнять лишь операцию SELECT, поэтому целесообразно было инициализацию server-side курсора вынести в метод **retrieve_many**, т.к. он используется только для этой операции. В остальных случаях прокси-курсор работает с client-side курсором.
В реализации asyncpg нету понятия client-side курсор, поэтому было решено использовать объект соединения напрямую для выполнения запросов. Также как и в psycopg, client-side курсор инициализируется только в методе **retrieve_many**.
Метод **retrieve_many** представляет собой генератор, который отдает то количество строк из БД, которое задал пользователь.
Таким образом, для синхронных запросов реализованы классы **ClientPsycopgCursorProxy** и **ServerPsycopgCursorProxy**, а для асинхронных - **ClientAsyncpgCursorProxy** и **ServerAsyncpgCursorProxy**.
Такое четкое разделение по классам позволяет гибко настраивать объекты прокси-соединений на работу с разными типами курсоров. В свою очередь репозитории принимают лишь один тип прокси-соединенния - синхронный или асинхронный.
